# Transforming spatial data to 3D forms

## Questions

* What tools exist to convert data to meshes in R? 


## Overview

* Teaching: X min
* Exercises: X min


## Transforming Spatial Data using modular 3D tools {.exercise}

1. Tell us if you use 3D visualization or meshes in analysis. 


This is hard! There's a few scattered tools. 

## On CRAN 

* `rgl::triangulate` and `decido::earcut` will triangulate polygons with holes but only suitable for plane-filling, because ugly triangles, no control over size and shape. 

* `RTriangle::triangulate` (and `sfdct::ct_triangulate`) do high-quality "near-Delaunay" triangulations

* `quadmesh::quadmesh` to create rgl-ready mesh3d from a raster

* `mapview::cubeView` does very compelling interactive raster-cube visualization

* `SymbolixAU/mapdeck`

* `tylermorganwall/rayshader`


Side note: there are many triangulation algorithms and many packages in R, but we need *constrained triangulation* to preserve all input edges - only a handful can do that, and RTriangle is the king (with a problematic license). 

Quadmesh. 


```{r, quadmesh}
library(quadmesh)
quadmesh(anyRasterDEM, texture = anyRasterRGB)
rgl::shade3d()

## play with aspect3d, light3d, ...

```

Triangulations, `sfdct` is no good because it's very inefficient. `sf` is simply not suitable for mesh (a.k.a. *indexed*) forms of data. 

## Stuff not on CRAN!

* `hypertidy/silicate`, `hypertidy/anglr` - these are evolving together 

* this workshop!  https://github.com/MilesMcBain/gis_vs_web3D 

* `coolbutuseless/threed`


## Triangles or quads in hypertidy (WIP)

This is my work-in-progress approach to meshing any data structure. 


```{r, eval=FALSE}
## devtools::install_github("hypertidy/anglr")
## devtools::install_github("hypertidy/silicate")
library(anglr)  
triangles <- copy_down(TRI(anySFpolygon), anyRasterDEM)

mesh <- plot3d(triangles)

```




## Create and texture a 3D mesh

Create and texture a 3D mesh in R from a variety of spatial data sources (e.g. Shapefile + digital elevation model + satellite raster).


Texture an image onto our hemisphere. 

```{r download_blue_marble, eval=TRUE}
library(quadmesh)
bm_url <- "https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73909/world.topo.bathy.200412.3x5400x2700.jpg"
bm_file <- basename(bm_url)
if (!file.exists(bm_file)) download.file(bm_url, bm_file)

bm_rgb <- raster::setExtent(raster::brick(bm_file), raster::extent(-180, 180, -90, 90))
projection(bm_rgb) <- "+proj=longlat +datum=WGS84"
bm_rgb <- raster::aggregate(bm_rgb, fact = 10)
south <- quadmesh(etopo, texture = bm_rgb)
south$vb[3, ] <- south$vb[3, ] * 20
south$vb[1:3, ] <- t(llh2xyz(t(south$vb[1:3, ])))
rgl.clear() 
shade3d(south)
aspect3d(1, 1, 0.5)
rglwidget()

```






